#
# readme
#
# notes on the new mac bootstrap code
#

This is, in effect, an almost total rewrite of my previous bootsector work,
but in C (with the help of some code I found in arch/amiga/stand/bootblock),
and without the SCSI access code.

This version has been set up to write 512k of data starting from RomBase to
the boot disk. I have been compiling it with -m68000, and using a hex editor
to change the one occurance of a long branch (dunno why it insists on putting
one in) to a short branch followed by a NOP, and running it on a Mac Classic.
Possible uses for this are left to the reader's imagination.

Install kernels are too big to fit on a floppy disk unless they are compressed.
Unfortunately, zlib is to big to fit in 8k. The best solution I have been able
to come up with for this problem is to use a multi-stage system, the first 8k
stage containing filesystem access routines (libsa?), and the second stage
being of indeterminate size, and containing libsa, libz, and any interactive
goodies we can be bothered implementing. While the linker I sto^H^H^Hborrowed
from arch/amiga is presently limited to an 8k binary, it shouldn't be that
hard to change it to only enforce that based on a command line switch (famous
last words). None of this has been implemented yet.

I see no reason to configure an application zone. QuickDraw can be set up on
the stack, and I put the stack and the A5 world in the system heap. The
linker and relocator resolve all absolute references, so the only trick is
keeping the compiler away from A5, which we do with -ffixed-a5.

When allocating memory for disk buffers, it should be possible to start at
BufPtr and just move downwards from there. Should save having to re-adjust
the heap sizes.

Something of importance will be determining the amount of RAM in the system
once we switch MMU modes. I actually don't have too much of a problem with
the first versions being limited to 8 megs, but when I break out the larger
SIMMs I will want them to work.

#
# EOF
#
